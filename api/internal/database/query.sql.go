// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const adminExists = `-- name: AdminExists :one
SELECT
  EXISTS (
    SELECT
      1
    FROM
      users
    WHERE
      ROLE = 'admin')
`

func (q *Queries) AdminExists(ctx context.Context) (bool, error) {
	row := q.db.QueryRow(ctx, adminExists)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createAdminUser = `-- name: CreateAdminUser :one
INSERT INTO users (email, role, password_hash)
  VALUES (trim(lower($2::text)), 'admin', $1)
RETURNING
  id
`

type CreateAdminUserParams struct {
	PasswordHash string
	Email        string
}

func (q *Queries) CreateAdminUser(ctx context.Context, arg CreateAdminUserParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createAdminUser, arg.PasswordHash, arg.Email)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT
  id,
  email,
  ROLE,
  password_hash
FROM
  users
WHERE
  email = trim(lower($1::text))
`

type GetUserByEmailRow struct {
	ID           uuid.UUID
	Email        string
	Role         Role
	PasswordHash string
}

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (GetUserByEmailRow, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i GetUserByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Role,
		&i.PasswordHash,
	)
	return i, err
}

const getUserIDs = `-- name: GetUserIDs :many
SELECT
  id
FROM
  users
ORDER BY
  created_at ASC
LIMIT $1
`

func (q *Queries) GetUserIDs(ctx context.Context, limit int32) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, getUserIDs, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserRefreshToken = `-- name: GetUserRefreshToken :one
SELECT
  refresh_token_hash,
  refresh_token_expires_at
FROM
  users
WHERE
  id = $1
`

type GetUserRefreshTokenRow struct {
	RefreshTokenHash      pgtype.Text
	RefreshTokenExpiresAt pgtype.Timestamptz
}

func (q *Queries) GetUserRefreshToken(ctx context.Context, id uuid.UUID) (GetUserRefreshTokenRow, error) {
	row := q.db.QueryRow(ctx, getUserRefreshToken, id)
	var i GetUserRefreshTokenRow
	err := row.Scan(&i.RefreshTokenHash, &i.RefreshTokenExpiresAt)
	return i, err
}

const getUserRole = `-- name: GetUserRole :one
SELECT
  ROLE
FROM
  users
WHERE
  id = $1
`

func (q *Queries) GetUserRole(ctx context.Context, id uuid.UUID) (Role, error) {
	row := q.db.QueryRow(ctx, getUserRole, id)
	var role Role
	err := row.Scan(&role)
	return role, err
}

const getUserSpotifyId = `-- name: GetUserSpotifyId :one
SELECT
  u.spotify_id
FROM
  users u
  JOIN spotify_tokens st ON st.spotify_user_id = u.spotify_id
WHERE
  u.spotify_id IS NOT NULL
  AND u.id = $1
`

func (q *Queries) GetUserSpotifyId(ctx context.Context, id uuid.UUID) (pgtype.Text, error) {
	row := q.db.QueryRow(ctx, getUserSpotifyId, id)
	var spotify_id pgtype.Text
	err := row.Scan(&spotify_id)
	return spotify_id, err
}

const getUserSpotifyRefreshToken = `-- name: GetUserSpotifyRefreshToken :one
SELECT
  st.refresh_token
FROM
  users u
  JOIN spotify_tokens st ON st.spotify_user_id = u.spotify_id
WHERE
  u.spotify_id IS NOT NULL
  AND u.id = $1
`

func (q *Queries) GetUserSpotifyRefreshToken(ctx context.Context, id uuid.UUID) (string, error) {
	row := q.db.QueryRow(ctx, getUserSpotifyRefreshToken, id)
	var refresh_token string
	err := row.Scan(&refresh_token)
	return refresh_token, err
}

const getUserSpotifyTokenExpiration = `-- name: GetUserSpotifyTokenExpiration :one
SELECT
  st.expires_at
FROM
  users u
  JOIN spotify_tokens st ON st.spotify_user_id = u.spotify_id
WHERE
  u.spotify_id IS NOT NULL
  AND u.id = $1
`

func (q *Queries) GetUserSpotifyTokenExpiration(ctx context.Context, id uuid.UUID) (pgtype.Timestamptz, error) {
	row := q.db.QueryRow(ctx, getUserSpotifyTokenExpiration, id)
	var expires_at pgtype.Timestamptz
	err := row.Scan(&expires_at)
	return expires_at, err
}

const ping = `-- name: Ping :exec
SELECT
  1
`

func (q *Queries) Ping(ctx context.Context) error {
	_, err := q.db.Exec(ctx, ping)
	return err
}

const updateUserRefreshToken = `-- name: UpdateUserRefreshToken :exec
UPDATE
  users
SET
  refresh_token_hash = $1,
  refresh_token_expires_at = $2
WHERE
  id = $3
`

type UpdateUserRefreshTokenParams struct {
	RefreshTokenHash      pgtype.Text
	RefreshTokenExpiresAt pgtype.Timestamptz
	ID                    uuid.UUID
}

func (q *Queries) UpdateUserRefreshToken(ctx context.Context, arg UpdateUserRefreshTokenParams) error {
	_, err := q.db.Exec(ctx, updateUserRefreshToken, arg.RefreshTokenHash, arg.RefreshTokenExpiresAt, arg.ID)
	return err
}

const updateUserSpotifyID = `-- name: UpdateUserSpotifyID :exec
UPDATE
  users
SET
  spotify_id = $1
WHERE
  id = $2
`

type UpdateUserSpotifyIDParams struct {
	SpotifyID pgtype.Text
	ID        uuid.UUID
}

func (q *Queries) UpdateUserSpotifyID(ctx context.Context, arg UpdateUserSpotifyIDParams) error {
	_, err := q.db.Exec(ctx, updateUserSpotifyID, arg.SpotifyID, arg.ID)
	return err
}

const updateUserSpotifyTokens = `-- name: UpdateUserSpotifyTokens :exec
UPDATE
  spotify_tokens
SET
  access_token = $1,
  refresh_token = $2,
  token_type = $3,
  scope = $4,
  expires_at = $5
WHERE
  spotify_user_id = $6
`

type UpdateUserSpotifyTokensParams struct {
	AccessToken   string
	RefreshToken  string
	TokenType     string
	Scope         string
	ExpiresAt     pgtype.Timestamptz
	SpotifyUserID string
}

func (q *Queries) UpdateUserSpotifyTokens(ctx context.Context, arg UpdateUserSpotifyTokensParams) error {
	_, err := q.db.Exec(ctx, updateUserSpotifyTokens,
		arg.AccessToken,
		arg.RefreshToken,
		arg.TokenType,
		arg.Scope,
		arg.ExpiresAt,
		arg.SpotifyUserID,
	)
	return err
}

const upsertUserSpotifyTokens = `-- name: UpsertUserSpotifyTokens :exec
INSERT INTO spotify_tokens (spotify_user_id, access_token, token_type, scope, refresh_token, expires_at)
  VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (spotify_user_id)
  DO UPDATE SET
    access_token = EXCLUDED.access_token,
    token_type = EXCLUDED.token_type,
    scope = EXCLUDED.scope,
    refresh_token = EXCLUDED.refresh_token,
    expires_at = EXCLUDED.expires_at
`

type UpsertUserSpotifyTokensParams struct {
	SpotifyUserID string
	AccessToken   string
	TokenType     string
	Scope         string
	RefreshToken  string
	ExpiresAt     pgtype.Timestamptz
}

func (q *Queries) UpsertUserSpotifyTokens(ctx context.Context, arg UpsertUserSpotifyTokensParams) error {
	_, err := q.db.Exec(ctx, upsertUserSpotifyTokens,
		arg.SpotifyUserID,
		arg.AccessToken,
		arg.TokenType,
		arg.Scope,
		arg.RefreshToken,
		arg.ExpiresAt,
	)
	return err
}
