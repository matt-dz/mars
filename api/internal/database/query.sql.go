// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addPlaylistTrack = `-- name: AddPlaylistTrack :exec
INSERT INTO playlist_tracks (playlist_id, track_id, plays)
  VALUES ($1, $2, $3)
`

type AddPlaylistTrackParams struct {
	PlaylistID uuid.UUID
	TrackID    string
	Plays      int32
}

func (q *Queries) AddPlaylistTrack(ctx context.Context, arg AddPlaylistTrackParams) error {
	_, err := q.db.Exec(ctx, addPlaylistTrack, arg.PlaylistID, arg.TrackID, arg.Plays)
	return err
}

const adminExists = `-- name: AdminExists :one
SELECT
  EXISTS (
    SELECT
      1
    FROM
      users
    WHERE
      ROLE = 'admin')
`

func (q *Queries) AdminExists(ctx context.Context) (bool, error) {
	row := q.db.QueryRow(ctx, adminExists)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createAdminUser = `-- name: CreateAdminUser :one
INSERT INTO users (email, role, password_hash)
  VALUES (trim(lower($2::text)), 'admin', $1)
RETURNING
  id
`

type CreateAdminUserParams struct {
	PasswordHash string
	Email        string
}

func (q *Queries) CreateAdminUser(ctx context.Context, arg CreateAdminUserParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createAdminUser, arg.PasswordHash, arg.Email)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const createPlaylist = `-- name: CreatePlaylist :one
INSERT INTO playlists (user_id, playlist_type, name)
  VALUES ($1, $2, $3)
RETURNING
  id
`

type CreatePlaylistParams struct {
	UserID       uuid.UUID
	PlaylistType PlaylistType
	Name         string
}

func (q *Queries) CreatePlaylist(ctx context.Context, arg CreatePlaylistParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createPlaylist, arg.UserID, arg.PlaylistType, arg.Name)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const createServiceAccount = `-- name: CreateServiceAccount :one
INSERT INTO users (email, role, password_hash)
  VALUES (trim(lower($2::text)), 'service', $1)
RETURNING
  id
`

type CreateServiceAccountParams struct {
	PasswordHash string
	Email        string
}

func (q *Queries) CreateServiceAccount(ctx context.Context, arg CreateServiceAccountParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createServiceAccount, arg.PasswordHash, arg.Email)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getPlaylistTracks = `-- name: GetPlaylistTracks :many
SELECT
  t.id,
  t.name,
  t.artists,
  t.href,
  t.image_url,
  t.uri,
  pt.plays
FROM
  playlist_tracks pt
  JOIN tracks t ON pt.track_id = t.id
WHERE
  pt.playlist_id = $1
ORDER BY
  pt.plays DESC,
  pt.track_id ASC
`

type GetPlaylistTracksRow struct {
	ID       string
	Name     string
	Artists  []string
	Href     string
	ImageUrl pgtype.Text
	Uri      string
	Plays    int32
}

func (q *Queries) GetPlaylistTracks(ctx context.Context, playlistID uuid.UUID) ([]GetPlaylistTracksRow, error) {
	rows, err := q.db.Query(ctx, getPlaylistTracks, playlistID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlaylistTracksRow
	for rows.Next() {
		var i GetPlaylistTracksRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Artists,
			&i.Href,
			&i.ImageUrl,
			&i.Uri,
			&i.Plays,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT
  email,
  ROLE
FROM
  users
WHERE
  id = $1
`

type GetUserRow struct {
	Email string
	Role  Role
}

func (q *Queries) GetUser(ctx context.Context, id uuid.UUID) (GetUserRow, error) {
	row := q.db.QueryRow(ctx, getUser, id)
	var i GetUserRow
	err := row.Scan(&i.Email, &i.Role)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT
  id,
  email,
  ROLE,
  password_hash
FROM
  users
WHERE
  email = trim(lower($1::text))
`

type GetUserByEmailRow struct {
	ID           uuid.UUID
	Email        string
	Role         Role
	PasswordHash string
}

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (GetUserByEmailRow, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i GetUserByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Role,
		&i.PasswordHash,
	)
	return i, err
}

const getUserIDs = `-- name: GetUserIDs :many
SELECT
  id
FROM
  users
ORDER BY
  created_at ASC
LIMIT $1
`

func (q *Queries) GetUserIDs(ctx context.Context, limit int32) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, getUserIDs, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserPlaylist = `-- name: GetUserPlaylist :one
SELECT
  id,
  playlist_type,
  name,
  created_at
FROM
  playlists
WHERE
  user_id = $1
  AND id = $2
`

type GetUserPlaylistParams struct {
	UserID uuid.UUID
	ID     uuid.UUID
}

type GetUserPlaylistRow struct {
	ID           uuid.UUID
	PlaylistType PlaylistType
	Name         string
	CreatedAt    pgtype.Timestamptz
}

func (q *Queries) GetUserPlaylist(ctx context.Context, arg GetUserPlaylistParams) (GetUserPlaylistRow, error) {
	row := q.db.QueryRow(ctx, getUserPlaylist, arg.UserID, arg.ID)
	var i GetUserPlaylistRow
	err := row.Scan(
		&i.ID,
		&i.PlaylistType,
		&i.Name,
		&i.CreatedAt,
	)
	return i, err
}

const getUserPlaylists = `-- name: GetUserPlaylists :many
SELECT
  id,
  playlist_type,
  name,
  created_at
FROM
  playlists
WHERE
  user_id = $1
ORDER BY
  created_at DESC
`

type GetUserPlaylistsRow struct {
	ID           uuid.UUID
	PlaylistType PlaylistType
	Name         string
	CreatedAt    pgtype.Timestamptz
}

func (q *Queries) GetUserPlaylists(ctx context.Context, userID uuid.UUID) ([]GetUserPlaylistsRow, error) {
	rows, err := q.db.Query(ctx, getUserPlaylists, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserPlaylistsRow
	for rows.Next() {
		var i GetUserPlaylistsRow
		if err := rows.Scan(
			&i.ID,
			&i.PlaylistType,
			&i.Name,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserRefreshToken = `-- name: GetUserRefreshToken :one
SELECT
  refresh_token_hash,
  refresh_token_expires_at
FROM
  users
WHERE
  id = $1
`

type GetUserRefreshTokenRow struct {
	RefreshTokenHash      pgtype.Text
	RefreshTokenExpiresAt pgtype.Timestamptz
}

func (q *Queries) GetUserRefreshToken(ctx context.Context, id uuid.UUID) (GetUserRefreshTokenRow, error) {
	row := q.db.QueryRow(ctx, getUserRefreshToken, id)
	var i GetUserRefreshTokenRow
	err := row.Scan(&i.RefreshTokenHash, &i.RefreshTokenExpiresAt)
	return i, err
}

const getUserRole = `-- name: GetUserRole :one
SELECT
  ROLE
FROM
  users
WHERE
  id = $1
`

func (q *Queries) GetUserRole(ctx context.Context, id uuid.UUID) (Role, error) {
	row := q.db.QueryRow(ctx, getUserRole, id)
	var role Role
	err := row.Scan(&role)
	return role, err
}

const getUserSpotifyAccessToken = `-- name: GetUserSpotifyAccessToken :one
SELECT
  st.access_token
FROM
  users u
  JOIN spotify_tokens st ON st.spotify_user_id = u.spotify_id
WHERE
  u.spotify_id IS NOT NULL
  AND u.id = $1
`

func (q *Queries) GetUserSpotifyAccessToken(ctx context.Context, id uuid.UUID) (string, error) {
	row := q.db.QueryRow(ctx, getUserSpotifyAccessToken, id)
	var access_token string
	err := row.Scan(&access_token)
	return access_token, err
}

const getUserSpotifyId = `-- name: GetUserSpotifyId :one
SELECT
  u.spotify_id
FROM
  users u
  JOIN spotify_tokens st ON st.spotify_user_id = u.spotify_id
WHERE
  u.spotify_id IS NOT NULL
  AND u.id = $1
`

func (q *Queries) GetUserSpotifyId(ctx context.Context, id uuid.UUID) (pgtype.Text, error) {
	row := q.db.QueryRow(ctx, getUserSpotifyId, id)
	var spotify_id pgtype.Text
	err := row.Scan(&spotify_id)
	return spotify_id, err
}

const getUserSpotifyRefreshToken = `-- name: GetUserSpotifyRefreshToken :one
SELECT
  st.refresh_token
FROM
  users u
  JOIN spotify_tokens st ON st.spotify_user_id = u.spotify_id
WHERE
  u.spotify_id IS NOT NULL
  AND u.id = $1
`

func (q *Queries) GetUserSpotifyRefreshToken(ctx context.Context, id uuid.UUID) (string, error) {
	row := q.db.QueryRow(ctx, getUserSpotifyRefreshToken, id)
	var refresh_token string
	err := row.Scan(&refresh_token)
	return refresh_token, err
}

const getUserSpotifyTokenExpiration = `-- name: GetUserSpotifyTokenExpiration :one
SELECT
  st.expires_at
FROM
  users u
  JOIN spotify_tokens st ON st.spotify_user_id = u.spotify_id
WHERE
  u.spotify_id IS NOT NULL
  AND u.id = $1
`

func (q *Queries) GetUserSpotifyTokenExpiration(ctx context.Context, id uuid.UUID) (pgtype.Timestamptz, error) {
	row := q.db.QueryRow(ctx, getUserSpotifyTokenExpiration, id)
	var expires_at pgtype.Timestamptz
	err := row.Scan(&expires_at)
	return expires_at, err
}

const listensByTrackInRange = `-- name: ListensByTrackInRange :many
SELECT
  track_id,
  COUNT(*)::bigint AS listen_count
FROM
  track_listens
WHERE
  user_id = $1
  AND played_at >= $2::timestamptz
  AND played_at < $3::timestamptz
GROUP BY
  track_id
ORDER BY
  listen_count DESC,
  track_id ASC
LIMIT 50
`

type ListensByTrackInRangeParams struct {
	UserID    uuid.UUID
	StartDate pgtype.Timestamptz
	EndDate   pgtype.Timestamptz
}

type ListensByTrackInRangeRow struct {
	TrackID     string
	ListenCount int64
}

func (q *Queries) ListensByTrackInRange(ctx context.Context, arg ListensByTrackInRangeParams) ([]ListensByTrackInRangeRow, error) {
	rows, err := q.db.Query(ctx, listensByTrackInRange, arg.UserID, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListensByTrackInRangeRow
	for rows.Next() {
		var i ListensByTrackInRangeRow
		if err := rows.Scan(&i.TrackID, &i.ListenCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ping = `-- name: Ping :exec
SELECT
  1
`

func (q *Queries) Ping(ctx context.Context) error {
	_, err := q.db.Exec(ctx, ping)
	return err
}

const serviceAccountExists = `-- name: ServiceAccountExists :one
SELECT
  EXISTS (
    SELECT
      1
    FROM
      users
    WHERE
      ROLE = 'service')
`

func (q *Queries) ServiceAccountExists(ctx context.Context) (bool, error) {
	row := q.db.QueryRow(ctx, serviceAccountExists)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const updateUserRefreshToken = `-- name: UpdateUserRefreshToken :exec
UPDATE
  users
SET
  refresh_token_hash = $1,
  refresh_token_expires_at = $2
WHERE
  id = $3
`

type UpdateUserRefreshTokenParams struct {
	RefreshTokenHash      pgtype.Text
	RefreshTokenExpiresAt pgtype.Timestamptz
	ID                    uuid.UUID
}

func (q *Queries) UpdateUserRefreshToken(ctx context.Context, arg UpdateUserRefreshTokenParams) error {
	_, err := q.db.Exec(ctx, updateUserRefreshToken, arg.RefreshTokenHash, arg.RefreshTokenExpiresAt, arg.ID)
	return err
}

const updateUserSpotifyID = `-- name: UpdateUserSpotifyID :exec
UPDATE
  users
SET
  spotify_id = $1
WHERE
  id = $2
`

type UpdateUserSpotifyIDParams struct {
	SpotifyID pgtype.Text
	ID        uuid.UUID
}

func (q *Queries) UpdateUserSpotifyID(ctx context.Context, arg UpdateUserSpotifyIDParams) error {
	_, err := q.db.Exec(ctx, updateUserSpotifyID, arg.SpotifyID, arg.ID)
	return err
}

const updateUserSpotifyTokens = `-- name: UpdateUserSpotifyTokens :exec
UPDATE
  spotify_tokens
SET
  access_token = $1,
  refresh_token = $2,
  token_type = $3,
  scope = $4,
  expires_at = $5
WHERE
  spotify_user_id = $6
`

type UpdateUserSpotifyTokensParams struct {
	AccessToken   string
	RefreshToken  string
	TokenType     string
	Scope         string
	ExpiresAt     pgtype.Timestamptz
	SpotifyUserID string
}

func (q *Queries) UpdateUserSpotifyTokens(ctx context.Context, arg UpdateUserSpotifyTokensParams) error {
	_, err := q.db.Exec(ctx, updateUserSpotifyTokens,
		arg.AccessToken,
		arg.RefreshToken,
		arg.TokenType,
		arg.Scope,
		arg.ExpiresAt,
		arg.SpotifyUserID,
	)
	return err
}

const upsertTrack = `-- name: UpsertTrack :exec
INSERT INTO tracks (image_url, id, name, artists, href, uri)
  VALUES ($6, $1, $2, $3, $4, $5)
ON CONFLICT (id)
  DO UPDATE SET
    updated_at = NOW(),
    image_url = EXCLUDED.image_url,
    name = EXCLUDED.name,
    artists = EXCLUDED.artists,
    href = EXCLUDED.href
`

type UpsertTrackParams struct {
	ID       string
	Name     string
	Artists  []string
	Href     string
	Uri      string
	ImageUrl pgtype.Text
}

func (q *Queries) UpsertTrack(ctx context.Context, arg UpsertTrackParams) error {
	_, err := q.db.Exec(ctx, upsertTrack,
		arg.ID,
		arg.Name,
		arg.Artists,
		arg.Href,
		arg.Uri,
		arg.ImageUrl,
	)
	return err
}

const upsertTrackListen = `-- name: UpsertTrackListen :exec
INSERT INTO track_listens (user_id, track_id, played_at)
  VALUES ($1, $2, $3)
ON CONFLICT (user_id, track_id, played_at)
  DO NOTHING
`

type UpsertTrackListenParams struct {
	UserID   uuid.UUID
	TrackID  string
	PlayedAt pgtype.Timestamptz
}

func (q *Queries) UpsertTrackListen(ctx context.Context, arg UpsertTrackListenParams) error {
	_, err := q.db.Exec(ctx, upsertTrackListen, arg.UserID, arg.TrackID, arg.PlayedAt)
	return err
}

const upsertUserSpotifyTokens = `-- name: UpsertUserSpotifyTokens :exec
INSERT INTO spotify_tokens (spotify_user_id, access_token, token_type, scope, refresh_token, expires_at)
  VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (spotify_user_id)
  DO UPDATE SET
    access_token = EXCLUDED.access_token,
    token_type = EXCLUDED.token_type,
    scope = EXCLUDED.scope,
    refresh_token = EXCLUDED.refresh_token,
    expires_at = EXCLUDED.expires_at
`

type UpsertUserSpotifyTokensParams struct {
	SpotifyUserID string
	AccessToken   string
	TokenType     string
	Scope         string
	RefreshToken  string
	ExpiresAt     pgtype.Timestamptz
}

func (q *Queries) UpsertUserSpotifyTokens(ctx context.Context, arg UpsertUserSpotifyTokensParams) error {
	_, err := q.db.Exec(ctx, upsertUserSpotifyTokens,
		arg.SpotifyUserID,
		arg.AccessToken,
		arg.TokenType,
		arg.Scope,
		arg.RefreshToken,
		arg.ExpiresAt,
	)
	return err
}
